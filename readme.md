# Unified Redux Wrapper

### Description

A wrapper build around redux to simplify, the steps involved in creating action creators, actions, and dispatching, it reduces the verbosity and steep learning curve associated with adopting redux in most SPA's most especially react.
The library solves the following problems when using redux

- Reduce verbosity : Imagine if you have to write actions and action creators, reducers and update the store with every api calls to the back end, you could end up with a lot of unmanaged files, where the propensity for introducing error is increased by the number of methods written, these library solves these problem by adopting a very cohesive design pattern where one reducer, action creators serves all this function for you
- Limit the chances of errors when writing multiple artifacts of conventional flux pattern
- It does not limit you from implementing the conventional approach of redux you are use to, you can use this approach intermittently with whatever approach you use
- This is not an extension to redux, just an implementation of a design pattern that promotes cohesiveness

### Documentation

- Typically you will use two methods from this library, which are `setUpCombinedReducers` and `dispatchActions`
- The `setUpCombinedReducers` combines your reducers (if any ) with the those actions you wish to use with the library
  You need to create a file that contains your actions , conventionally this file is called `actionDictionary.js`

  - create a variable within this file like this
    ```
    const actionDictionary = { }
    ```
  - add your actions (as Block cased keys and values seperated by underscore ) e.g

    ```
       const actionDictionary = {
           MY_FIRST_ACTION: 'MY_FIRST_ACTION',
           MY_SECOND_ACTION: 'MY_SECOND_ACTION'
        }
    ```

    - this key/values within the objects become camelized in your store so they can be accessed as

    ```
    myFirstAction and mySecondAction
    ```

  - so when creating your store please follow the approach


      ```
      import { createStore, applyMiddleware, compose } from "redux";

...
import { setUpCombinedReducers } from "unified-redux-wrapper";
import { actionDictionary } from "actions"; // your defined action dictionary , could be located anywhere

const initialState = {};

....

const store = createStore(
setUpCombinedReducers(actionDictionary), // here we inject the reducers generated by the library
initialState,
composedEnhancers
);
...
export default store;

```

- Use the Module in a React component, -
  When creating you Import the library on the react component as below,
```

import { dispatchActions} from 'unified-redux-wrapper'

```

Implement match state to props as,

## Asynchronous updates

typically each element in your store will have three state

1.  **pending** : the pending state will be false, initially and it is only applicable when updating your store with an asynchronous function, when the function is being called the state will be true
  and it is a very good time to add loaders or use react suspense , the payload and the error state will be set to null
2.  **payload**: after the pending state the variable will have a payload state set to the value of the returned element and pending state will be set to false
3.  **error**: if the asynchronous call errors out then the error state will be set to the description of the error encountered, otherwise it is null/false

```

## synchronous updates

for synchronous updates all the above are true asides from there will be **no pending state**

### Examples

For the example of the variable in the store here is how to use

```

const matchStateToProps = ({myFirstAction, mySecondAction}) => ({
myFirstActionPending: myFirstAction.pending // here is the pending state, it is false until an asynchronous dispatch is called - this is omited in synchrnous calls
myFirstActionPayload: myFirstAction.payload // here is the state when the items are loaded in the store
myFIrstActionError: myFirstAction.error // here is what happens when an error is encountered when updating the store
 });

```

Implement match dispatch to props as,

```

const matchDispatchToProps = (dispatch) => {
return bindActionCreators(
{
dispatchActions
}
), dispatch};

```

Each item of the store have three states

## Using the actioncreator

To call the actionCreator for request is
here are the parameters

1. **dictKey**: This is the value representing the store item you wish to ubdate , referring to our example this will be `'MY_FIRST_STORE'`
2. **eventAction**: This is a method/values representing the action you want to call or update respectively , typically it could be an api call , for instance if i have a function that calls my endpoint called `callEndPoint`
   this method will be passed as a varibale to the function. For synchronous request , this could be a function that returns values , or the values with wich we wish to update the store by
3. **isAsync**: it is true for asynchronous reqests and false for synchronous request
4. **parameter**: if the event action is a method that requires parameters, please pass an array of this parameter in the order they are called within the method to this variable, if not pass an empty array
5. **actionDictionary**: You should pass the action dictionary as the last parameter

To call the dispatchActions within your components

for asynchromous calls

```

this.props.dispatchActions(<dictKey>, <eventAction>, true, [<url>, <anyotherparam>], <actionDictionary>)

```

for synchronous calls

```

this.props.dispatchActions(<dictKey>, <eventAction>, false, [<anyparam for functions>], <actionDictionary>)

```

- you can pass in functions, promises, or objects as parameter to to the dispatch actions

```

```
