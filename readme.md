# Unified Redux Wrapper

### Description

A wrapper built around redux to simplify the adoption of redux which tuyically involves

- creating action creators
- actions,
- dispatching Actions
  This cycle needs to be repeated almost every time for API requests essentaily, any time the store needs to be updated.
  This wrapper reduces this verbosity using the same design pattern recommended by the redux team, it abstracts the repititve files into smaller easy steps

## Prblem Statement

The library solves the following problems peculiar to implementing state management using redux.

- Reduce verbosity, this wrapper abstracts all the boiler plates and exposes only few steps
- Limit the chances of errors when writing multiple artifacts of conventional flux pattern: To update the store if you have to write actions and action creators, reducers and update the store with every api calls to the back end, you could end up with a lot of unmanaged files, where the propensity for introducing error is increased by the number of methods written, these library solves these problem by adopting a very cohesive design pattern where one reducer, action creators serves all this function for you
- Modular and highly cohesive which maskes your implementations highly extendable and maintainable
- It does not limit you from implementing the conventional approach of redux you are used to, you can use this approach intermittently with whatever approach you are familiar with
- This is not an extension to redux, just an implementation of a design pattern that promotes cohession

### Documentation

- **Typically you will use two methods from this library, which are `setUpCombinedReducers` and `dispatchActions`**
- The `setUpCombinedReducers` combines your reducers (if any ) with the those actions you wish to use with the library
  You need to create a file that contains your actions , conventionally this file is called `actionDictionary.js`

- create a variable within this file like this

  `const actionDictionary = { }`

- add your actions (as Block cased keys and values seperated by underscore ) e.g

```
 const actionDictionary = {
 MY_FIRST_ACTION: 'MY_FIRST_ACTION',
 MY_SECOND_ACTION: 'MY_SECOND_ACTION'
 }
```

- You can update this file when you want to add more items to your store

- these key/values within the objects become camelized in your store so they can be accessed as


    `myFirstAction and mySecondAction`

- When creating your store (as defined in the redux doce) please follow the approach defined below


        import { createStore } from "redux";
        import { setUpCombinedReducers } from "unified-redux-wrapper";
        import { actionDictionary } from "actions";
        // your defined action dictionary , could be located anywhere
        ...
        const store = createStore(
        setUpCombinedReducers(actionDictionary),
        // here we inject the reducers generated by the library, you can pass any other reducer as an argument to  this method
        initialState, // iniital state
        );

        export default store;

### Use the Module in a React component

**When creating a component you Import the library on the react component as below**,

`
import { dispatchActions} from 'unified-redux-wrapper'

`
The imported method (dispatchActions) serve as the singular action creator which you should use accross the whole application, so it should be passed to matchState to props as :

**Implement match state to props as**,

## Asynchronous updates

Typically each element in your store will have three state

1.  **pending** : The pending state will be false, initially and it is only applicable when updating your store with an asynchronous function, when the function is being called, the state will initially be true and this is mostly a very good time to add loaders or suspense to your application. When the pending state is true, the payload and the error state will be set to null, the action called during this state will be `REQUEST_<Your action>`
2.  **payload**: after the pending state is called and the ashynchronous call returns a value, the variable will have a payload state set to the value of the returned element while pending state, and error state will be set to null. At thsis state the action will be `RECIEVE_<Your action>`
3.  **error**: if the asynchronous/Synhronous call errors out then the error state will be set to the description of the error encountered, otherwise it is null/false, the action at this state will be `FAIL_<Your action>`

## synchronous updates

for synchronous updates all the above are true asides from there will be **no pending state**

### Examples

**For the example of the variable in the store here is how to use**

        const matchStateToProps = ({myFirstAction, mySecondAction}) => ({
        myFirstActionPending: myFirstAction.pending // here is the pending state, it is false until an asynchronous dispatch is called - this is omited in synchrnous calls
        myFirstActionPayload: myFirstAction.payload // here is the state when the items are loaded in the store
        myFIrstActionError: myFirstAction.error // here is what happens when an error is encountered when updating the store
        });

**Implement match dispatch to props as**,

        const matchDispatchToProps = (dispatch) => {
        return bindActionCreators(
        {
        dispatchActions
        }
        ), dispatch};

Each item of the store have three states

## Using the actioncreator

To call the actionCreator for request is
here are the parameters

1. **dictKey**: This is the value representing the store item you wish to ubdate , referring to our example this will be `'MY_FIRST_STORE'`
2. **eventAction**: This is a method/values representing the action you want to call or update respectively , typically it could be an api call , for instance if i have a function that calls my endpoint called `callEndPoint`
   this method will be passed as a varibale to the function. For synchronous request , this could be a function that returns values , or the values with wich we wish to update the store by
3. **isAsync**: it is true for asynchronous reqests and false for synchronous request
4. **parameter**: if the event action is a method that requires parameters, please pass an array of this parameter in the order they are called within the method to this variable, if not pass an empty array
5. **actionDictionary**: You should pass the action dictionary as the last parameter

To call the dispatchActions within your components

for asynchromous calls

        this.props.dispatchActions(<dictKey>, <eventAction>, true, [<url>, <anyotherparam>], <actionDictionary>)

for synchronous calls

        this.props.dispatchActions(<dictKey>, <eventAction>, false, [<anyparam for functions>], <actionDictionary>)

- you can pass in functions, promises, or objects as parameter to to the dispatch actions
